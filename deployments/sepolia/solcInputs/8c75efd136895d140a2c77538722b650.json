{
  "language": "Solidity",
  "sources": {
    "contracts/DocumentManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.8;\n\n//imports\nimport \"./UserManager.sol\";\n\ncontract DocumentManager {\n    //modifiers\n    modifier onlyRegisteredUser() {\n        require(\n            userManager.getUser(msg.sender).accountAddress == msg.sender,\n            \"User is not registered\"\n        );\n        _;\n    }\n\n    //structure to represent a Document\n    struct Document {\n        uint256 documentId;\n        string documentName;\n        address ownerAddress;\n        string ipfsHash;\n    }\n\n    //mapping to store documents by user\n    mapping(address => Document[]) private userToDocuments;\n\n    UserManager private userManager;\n    uint256 private documentIdCounter; //unique to each document\n    Document[] private documents;\n\n    //constructor\n    constructor(UserManager _userManager) {\n        userManager = _userManager;\n        documentIdCounter = 0;\n    }\n\n    /**\n     * @dev Uploads a new document for a user.\n     * @param documentName The name of the document.\n     * @param ipfsHash The IPFS hash of the document.\n     * @param userAddress The address of the user.\n     */\n    function uploadDocument(\n        string memory documentName,\n        string memory ipfsHash,\n        address userAddress\n    ) external onlyRegisteredUser {\n        require(bytes(ipfsHash).length > 0, \"IPFS Hash cannot be empty.\");\n        Document memory newDocument = Document({\n            documentId: documentIdCounter,\n            documentName: documentName,\n            ipfsHash: ipfsHash,\n            ownerAddress: userAddress\n        });\n        //add the new document to the mapping\n        userToDocuments[userAddress].push(newDocument);\n        documents.push(newDocument);\n        documentIdCounter++;\n    }\n\n    /**\n     * @dev Retrieves all documents for a user.\n     * @param userAddress The address of the user.\n     * @return An array of Document structs representing the user's documents.\n     */\n    function getUserDocuments(\n        address userAddress\n    ) external view onlyRegisteredUser returns (Document[] memory) {\n        return userToDocuments[userAddress];\n    }\n\n    /**\n     * @dev Retrieves a document by its ID.\n     * @param documentId The ID of the document.\n     * @return The Document struct representing the document.\n     */\n    function getDocument(\n        uint256 documentId\n    ) public view onlyRegisteredUser returns (Document memory) {\n        require(documentId < documents.length, \"Invalid document ID\");\n        return documents[documentId];\n    }\n\n    /**\n     * @dev Checks if a document exists.\n     * @param documentId The ID of the document.\n     * @return A boolean indicating whether the document exists or not.\n     */\n    function documentExists(\n        uint256 documentId\n    ) public view onlyRegisteredUser returns (bool) {\n        return documentId < documents.length;\n    }\n\n    /**\n     * @dev Retrieves the owner address of a document.\n     * @param documentId The ID of the document.\n     * @return The address of the document owner.\n     */\n    function getDocumentOwner(\n        uint256 documentId\n    ) public view onlyRegisteredUser returns (address) {\n        require(documentExists(documentId), \"Document does not exist\");\n        return documents[documentId].ownerAddress;\n    }\n}\n"
    },
    "contracts/UserManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.8;\n\n//errors\nerror UserManager__InvalidDOB(bytes32 rollNumber, bytes32 DOB);\nerror UserManager__InvalidPrivateKey(address accountAddress);\nerror UserManager__InvalidPassword(string emailId, string password);\nerror UserManager__RollNumberNotFound(bytes32 rollNumber);\n\n/**\n * @title UserManager\n * @notice A contract to register and login users\n */\ncontract UserManager {\n    //events\n    event UserRegistered(bytes32 indexed rollNumber, bytes32 DOB);\n    event UserLoggedIn(address accountAddress);\n    event AdminRegistered(string indexed emailId, address adminAddress);\n    event AdminLoggedIn(address accountAddress);\n\n    //structs for User and Admin\n    struct User {\n        bytes32 rollNumber;\n        bytes32 dateOfBirth;\n        address accountAddress;\n    }\n    struct Admin {\n        string emailId;\n        address account;\n    }\n\n    //variables\n    string private constant PASSWORD = \"something_else\";\n    mapping(bytes32 => bytes32) private rollNumberToDOB; //sign-up\n    mapping(address => User) private users; //for login\n    // Declare an array to store user addresses\n    address[] private userAddresses; //for finding address from roll_number\n    mapping(address => Admin) private admins; //login of Admins (O(logn) time complexity)\n\n    /**\n     * @notice Registers a new user\n     * @param DOB The date of birth of the user\n     * @param rollNumber The roll number of the user\n     */\n    function registerUser(bytes32 DOB, bytes32 rollNumber) external {\n        if (rollNumberToDOB[rollNumber] != DOB) {\n            revert UserManager__InvalidDOB(rollNumber, DOB);\n        }\n        User memory newUser = User({\n            rollNumber: rollNumber,\n            dateOfBirth: DOB,\n            accountAddress: msg.sender\n        });\n        users[msg.sender] = newUser;\n        userAddresses.push(msg.sender);\n        emit UserRegistered(rollNumber, DOB);\n    }\n\n    /**\n     * @notice Logs in a user by verifying their private key\n     * @return result True if the login is successful, false otherwise\n     */\n    function loginUser() external returns (bool result) {\n        if (users[msg.sender].rollNumber == \"\") {\n            return false;\n        }\n        emit UserLoggedIn(msg.sender);\n        return true;\n    }\n\n    /**\n     * @notice Gets the details of a particular user\n     * @param userAddress The address of the user\n     * @return user The user details\n     */\n    function getUser(address userAddress) external view returns (User memory) {\n        if (users[userAddress].rollNumber == \"\") {\n            revert UserManager__InvalidPrivateKey(userAddress);\n        }\n        return users[userAddress];\n    }\n\n    //Admin Functionalities\n    /**\n     * @notice Registers a new admin\n     * @param emailId The email ID of the admin\n     * @param password The password of the admin\n     */\n    function registerAdmin(\n        string memory emailId,\n        string memory password\n    ) public {\n        if (keccak256(bytes(password)) != keccak256(bytes(PASSWORD))) {\n            revert UserManager__InvalidPassword(emailId, password);\n        }\n        Admin memory newAdmin = Admin({emailId: emailId, account: msg.sender});\n        admins[msg.sender] = newAdmin;\n        emit AdminRegistered(emailId, msg.sender);\n    }\n\n    /**\n     * @notice Logs in an admin\n     * @return result True if the login is successful, false otherwise\n     */\n    function loginAdmin() external returns (bool result) {\n        if (admins[msg.sender].account == address(0)) {\n            return false;\n        }\n        emit AdminLoggedIn(msg.sender);\n        return true;\n    }\n\n    /**\n     * @notice Sets the date of birth for a given roll number\n     * @param rollNumber The roll number of the user\n     * @param dateOfBirth The date of birth of the user\n     */\n    function setRollNumberToDOB(\n        bytes32 rollNumber,\n        bytes32 dateOfBirth\n    ) external {\n        rollNumberToDOB[rollNumber] = dateOfBirth;\n    }\n\n    /**\n     * @notice Gets the date of birth for a given roll number\n     * @param rollNumber The roll number of the user\n     * @return dateOfBirth The date of birth of the user\n     */\n    function getRollNumberToDOB(\n        bytes32 rollNumber\n    ) external view returns (bytes32) {\n        return rollNumberToDOB[rollNumber];\n    }\n\n    /**\n     * @notice Finds the account address by roll number\n     * @param rollNumber The roll number of the user\n     * @return accountAddress The account address of the user\n     */\n    function findAccountAddressByRollNumber(\n        bytes32 rollNumber\n    ) public view returns (address) {\n        for (uint256 i = 0; i < userAddresses.length; i++) {\n            address userAddress = userAddresses[i];\n            if (users[userAddress].rollNumber == rollNumber) {\n                return userAddress;\n            }\n        }\n        revert UserManager__RollNumberNotFound(rollNumber);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}